# Java集合
**Java集合**分为Conllector（存储对象），Map（存储KV键值）和JUC集合（高性能并发安全）。
**主要集合类型包括**：List（含栈、队列等），Set，Map。
**List**底层为数组，链表，特殊的还有堆（优先队列底层）。
**Map**底层为哈希表，链表，红黑树。（**Set**底层与Map实现方式相同，通过Key值唯一实现元素不可重复）  
>红黑树：一种自平衡二叉树，通过颜色限制实现**不完全平衡**（AVL树通过平衡因子实现平衡）。相较于AVL树，红黑树是不严格的平衡二叉树，因而搜索性能较低，插入删除性能较高。AVL搜索O(logN)，增删O(logN)，红黑树搜索最坏O(2logN)，增删O(logN)（更少的旋转次数&重平衡触发频率）。

**基于数组的集合特点**：有插入序（范围查询O(N)），读O(1)，写最差O(N)。
**基于链表的集合特点**：有插入序（范围查询O(N)），读写最差O(N)。
**基于哈希表的集合特点**：无序（范围查询O(N)），读写O(1)时间复杂度，不支持模糊查询。
**基于红黑树的集合特点**：有自然序（范围查询时间复杂度取决于范围大小，确定范围为O(2logN)），读写O(logN)。
>Tips：对于基于哈希表的集合来说，实现元素判等，不能通过重写equals方法实现，详见学习笔记[Java基础](https://github.com/mooneed/JavaBackendNotes/blob/main/Java/1.Java%E5%9F%BA%E7%A1%80.md)的Object类一节。应通过compareTo方法实现。  

**集合和数组的区别**：  
（1）集合符合面向对象思想，数组不符（可以存储基本类型）；  
（2）数组长度固定；  
（3）集合允许存储不同类型（通常不会）。  

# HashMap原理

## 自动扩容&自动转红黑树/退链表
6 8 64



# 并发安全集合
List：CopyOnWriteArrayList（引入快照）。
Map：ConcurrentHashMap（1.7引入分段锁，并发度受段数限制）（1.8）。
## ConcurrentHashMap
**JDK1.7分段锁Segment方案的缺点**：  
（1）增删改查操作需两次寻址；  
（2）segment数组不可扩容，只能对segment数组各位置的HashMap扩容。  
**JDK1.8ConcurrentHashMap实现方案**：  
以哈希表每个位置（被称为**桶**）为粒度的分段锁。使用CAS方式加锁。put操作找到对应的桶尝试加锁（成功则插入&**基准计数**+1；失败则自旋重试）；get操作找到对应的桶尝试加锁（成功则查找链表/红黑树&**本地计数**+1；失败则自旋重试）；扩容操作对每个桶加锁，


## CopyOnWriteArrayList
**CopyOnWriteArrayList缺点**：  
（1）写操作需拷贝数据，会消耗内存，如果原数组元素较多，容易触发Minor GC或Full GC；（**`慎用该类，生产环境非常容易引发事故`**）
（2）非实时一致性（能做到最终一致性），set后读取到的数据可能还是旧的。（不适用于实时读场景）



# 待解决问题
（1）为什么并发业务环境下，仍可使用ArrayList？因为没有修改操作或ArrayList为线程内的局部变量。（比如服务器为4核，并发同时处理4个请求，每个请求调用Service方法，方法中实例化ArrayList，此时ArrayList属于线程栈内的局部变量）
（2）