# 概述
**MySQL网课**：MySQL45讲-丁奇（**`MySQL核心参考资料`**）（学习曲线较平缓，知识点之间分离度较低）  
**MySQL博客**：[MySQL江湖路|专栏目录](https://blog.csdn.net/qq_39390545/article/details/107786761)（可参考，对MySQL45讲有一定补充）  
**数据库作用**：数据库用于存储和读取数据，对于业务端来说是一种共享资源。  
数据库理论的各种架构设计主要为了保证数据库系统的高性能，数据一致性，高可用性。  
下述架构设计中，√代表其主要目的，×代表对其他核心目的造成了负面影响。  
| 架构设计名称 | 高性能 | 一致性 | 高可用性 | 备注 |
| :-------------: | :-: | :---: | :--: | :------------: |
|     索引    |   √   |        |         |      |
| 数据库缓存  |  √  |   ×   |      |   MySQL有自己的缓存机制  |
| 分库分表    |  √  |       |      |                |
| 读写分离    |  √  |       |      |                |
| 引入外部中间件 |  √  |   ×   |      |    ES，远程缓存等    |
| 事务        |     |   √   |      |                |
| 锁        |  ×  |   √   |      |                |
| MVCC（undolog实现） |  √  |   √   |      |                |
| 主备       |     |   ×   |   √  |  主备延迟越短，可用性越高  |
| redolog\&binlog |  √  |   √   |   √  | （1）WAL技术减轻写盘压力；（2）保证MySQL崩溃/主机宕机的数据一致性；（3）binlog是分布式数据系统架构的同步核心（分布式是高可用的核心）|

**数据库的主要指标**：每秒事务数TPS，每秒查询数QPS。  
# 事务
事务的特性AICD  
并发问题  
事务的隔离级别  
隔离级别的实现  
MVCC  
>Tips：MVCC是乐观锁思想的一种实现，并不等同于乐观锁。MVCC基于乐观锁的思想认为在一个事务访问某数据时，别的事务不会/很少删改该数据。在这种情况下，就可以用很少的代价暂时存储该数据的历史版本链（undolog实现）。对于访问该数据的事务，在其整个事务生命周期内，其他事务的删改是不可见的。  

隔离级别的选择（数据一致性要求高选择可重复读，要求不高选择读已提交，什么场景数据一致性要求不高？）  
在可重复读隔离级别下，很大程度上避免了幻读问题。（未完全解决）  
MVCC解决快照读幻读问题。  
LBCC解决当前读幻读问题。  
**未被解决的幻读场景**：对于事务A的快照读不可见的数据，在当前读时是可见的。  
# MySQL日志
# 性能优化
学习**性能优化**一节的顺序通常应该放置在索引和锁后。但是由于高性能是MySQL设计和使用的核心目标之一，且性能优化是对索引的利用，以及对锁引发的性能问题的规避。因此，先学习性能优化能够更好地理解索引的原理以及锁的缺点。（**`对于本节出现的索引和锁的相关概念可以略读后两节`**）
## 慢查询优化
## 并发锁问题
锁导致的各种性能问题。
### 安全更新
更新或删除语句为当前读，如果没有使用索引的话，会导致整个表被锁住，造成业务停滞（阻塞增删改操作）。  
**解决方案**：设置参数sql_safe_updates为1。  
>update语句必须满足如下条件之一才能执行成功：  
（1）使用where，且条件中必须有索引列；  
（2）使用limit；  
（3）同时使用where和limit，条件中可以没有索引列。  
delete语句必须满足以下条件能执行成功：  
（1）同时使用where和limit，条件中可以没有索引列。  
Tips：如果优化器最终选择扫描全表，请手动force index([index_name])。  
### 避免死锁
（1）尽量减少事务持有锁的个数（拆分事务）；  
（2）DML与增删改查分离，避免增删改查持有锁的时间过长；  
（3）等。  
>此外优化SQL，合理增加索引，减少SQL执行时间，也可以减少锁的持有时间，避免死锁问题。  

# 索引

# 锁
锁，**以烧水为例**：有3壶水需要烧开，但是只有一个烧水壶，在烧水壶烧水的时候，必定有一壶水占用了烧水壶，不允许另外2壶水使用。该过程中的**水占用烧水壶并阻止其他水使用烧水壶即为锁**。此时烧水壶是**共享资源**，3壶水各是1位**竞争者**。  
在MySQL中，竞争者为不同的线程/事务，共享资源为数据库中的数据，线程/事务占用数据时对数据加锁。  
**锁的作用**：处理并发环境下的数据一致性问题。  
**锁引入的问题**：降低性能。  
**锁的性能问题的解决方案**：降低锁的粒度，采用乐观锁，避免死锁，等。  
**MySQL锁包括**：  
（1）全局锁；  
（2）表级锁：表锁，元数据锁，意向锁（InnoDB支持），AUTO-INC锁（InnoDB支持）；  
（3）行级锁（InnoDB支持）：记录锁，间隙锁，临键锁，插入意向锁。   
## 全局锁
顾名思义，对整个数据库加锁。实际上全局锁可以解决所有并发问题，但是性能过差所以被淘汰，仅剩下文所述的应用场景。  
**全局锁的作用**：使整个数据库处于只读状态：阻塞数据的增删改操作，阻塞表结构的更改操作。  
**全局锁的加/解锁语句**：  
```SQL
// 加锁
flush tables with read lock
// 解锁
unlock tables
```  
**全局锁的适用场景**：全库逻辑备份。  
**全局锁的缺点**：造成业务停滞（不能增删改数据）。  
**全局锁的上位替代**：MVCC实现的可重复读隔离级别（InnoDB支持）。对快照读的数据进行全库逻辑备份可以确保数据一致性（缺点：需要一个长事务执行全库逻辑备份）。  
## 表级锁
**表级锁的加锁对象**：表。
### 表锁
顾名思义，表锁就是对整张表加锁。表锁可以解决所有的并发问题，但是碍于性能原因，所以一方面拆分出了其他表级锁（意向锁除外），在解决更具体并发问题的同时提升性能，另一方面InnoDB提供了行级锁代替表锁处理行级的并发问题。  
**表锁的作用**：行锁出现前，处理并发数据不一致问题的主要锁。  
**表锁的加/解锁语句**：
```SQL
// 表级锁粒度的共享锁（读锁）
lock tables t_student read;
// 表级锁粒度的独占锁（写锁）
lock tables t_student write;
// 释放当前会话所有表锁
unlock tables
```
**表锁的缺点**：粒度大，影响并发性能。  
**表锁的适用场景**：（待研习，读者请跳过或自行学习）  
（1）事务更新大部分时；  
（2）事务涉及多个表，容易引起死锁，造成事务回滚。  

### 元数据锁MDL
**元数据锁的作用**：对表执行CRUD操作时，防止其他事务对表结构进行更改。  
**元数据锁的加/解锁**：MDL锁由MySQL隐式自动加/解锁。对表执行CRUD操作时加**MDL读锁**，对表结构执行更改操作时加**MDL写锁**，事务提交后自动**释放**。  
**元数据锁的缺点**：MDL写锁阻塞orMDL写锁加锁，都会导致MDL读锁全部阻塞。（前者因为在MDL锁阻塞队列中MDL写锁的优先级高于MDL读锁，后者因为事务提交后MDL写锁才会被释放）（例：长事务导致阻塞MDL写锁or长事务中使用MDL写锁）  
### 意向锁
**意向锁的作用**：加独占表锁时，快速判断表中是否有行锁（如果没有意向锁的话，加独占表锁时需要逐行检查是否有行锁）。（**`意向锁仅和表锁冲突`** 从其作用也很容易看出）  
>Tips：表锁与行锁也满足读读共享，读写/写写互斥。

**意向锁的加/解锁语句**：（加/解锁记录锁时自动加/解锁）  
```SQL
// 先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;
// 先在表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
// 事务提交后自动释放
```
### AUTO-INC锁
**AUTO-INC锁的作用**：保证自增主键（声明AUTO_INCREMENT的主键字段）的自动连续递增（自动：插入数据时无需指定主键值）。  
**AUTO-INC锁的加/解锁**：对主键自增的表执行插入操作时，自动加锁；插入操作执行完成后，自动释放（而非事务提交后释放）。  
**AUTO-INC锁的缺点**：表级锁，在大量插入时影响插入性能。  
**AUTO-INC锁的改进**：InnoDB支持通过变量innodb_autoinc_lock_mode设置自增锁模式，0为AUTO-INC锁，2为轻量级锁（申请自增主键后立即释放，无需等待语句执行）。
>Tips：轻量级锁搭配binlog的statement格式时，会导致主从复制数据不一致问题（解决方案为使用row格式binlog）。多种场景下statement格式均易导致主从复制数据不一致问题，详见上文**MySQL日志**一节。  
## 行级锁
>行级锁由InnoDB引擎提供支持。  

**行级锁的加锁对象**：记录行对应的索引。  
**行级锁的加锁**会根据语句的扫描方式不同，而有不同的加锁方案：  
（1）主键索引扫描；  
（2）二级索引扫描；  
（3）全表扫描。  
>Tips：对于执行全表扫描的语句，会对每一条记录的索引加临键锁，相当于锁定整个表（必须避免）。  

InnoDB默认优先加**临键锁**，非可重复读隔离级别加记录锁（因为间隙锁/临键锁仅存在于可重复读隔离级别）；部分可重复读隔离级别的场景下，临键锁退化为间隙锁/记录锁。**间隙锁/临键锁为了解决可重复读隔离级别的幻读问题**。  
本笔记主要介绍各行级锁的作用以及用法（略读时，可以简单的理解为InnoDB可重复读隔离级别全部使用临键锁，其他级别使用记录锁）。具体加锁分析，详见[小林coding图解MySQL](https://www.xiaolincoding.com/mysql/lock/how_to_lock.html)。
>Tips：在大多数生产环境中，表都是使用单调递增主键（如自增主键，UUID，雪花ID等），在插入操作时都是尾插，因此对间隙锁、临键锁、插入意向锁的使用频率较小。（个人观点，未验证）  

**行级锁的加/解锁语句**：（记录锁，间隙锁，临键锁共用语句）  
（1）当前读（会对记录加锁。普通的select语句为快照读，不会对记录加锁）  
```SQL
// 加共享锁
select ... lock in share mode;
// 加独占锁
select ... for update;
// 事务提交后自动释放
```
（2）增删改操作（也为当前读）：执行增删改语句时自动加锁，事务提交后自动释放。  
>Tips：在读提交和可重复读隔离级别下，由于MVCC机制的存在，快照读并不会被独占锁阻塞。  

### 记录锁
记录锁会锁定一条记录，实际上是**锁定记录对应的索引**，如果是二级索引扫描方式则锁定记录对应的二级索引和主键索引。  
**记录锁的作用**：处理并发数据不一致问题的主要锁。  
**记录锁的加/解锁**：非可重复读隔离级别下的默认行级锁；在可重复读隔离级别的部分场景下，临键锁降级为记录锁。  
### 间隙锁
间隙锁会锁定一个范围，阻塞在该范围内的插入操作。  
**间隙锁的作用**：解决可重复读隔离级别下的幻读问题（仅存在于可重复读隔离级别）。（**`间隙锁之间共享`**，因为间隙锁的目的是防止插入幻影记录，幻读问题详见**事务**一节）  
**间隙锁的加/解锁**：在可重复读隔离级别的部分场景下，临键锁降级为间隙锁。

### 临键锁
临键锁是行锁+间隙锁的组合。既锁定一个范围，又锁定记录本身。  
间隙锁为前开后开，临键锁为前开后闭。（需配图）  
**临键锁的作用**：同时起到记录锁和间隙锁的作用。  
**临键锁的加/解锁**：可重复读隔离级别下的默认行级锁。  
>Tips：在使用记录锁/间隙锁就能避免幻读问题的场景下，临键锁就会退化为记录锁/间隙锁。  

>Tips：禁用间隙锁时，临键锁也会被禁用。  
### 插入意向锁
**插入意向锁的作用**：插入前判断插入位置是否存在间隙锁，有则阻塞插入操作（相当于插入操作的锁，删改查有对应的行级锁，而增没有）。（**`插入意向锁之间共享`** ）  
**插入意向锁的加/解锁**：执行插入操作前，自动加锁；。  
## 死锁问题
死锁问题建议精读小林coding的死锁章节的案例分析[1](https://www.xiaolincoding.com/mysql/lock/deadlock.html)，[2](https://www.xiaolincoding.com/mysql/lock/show_lock.html#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C)。  
**死锁容易发生的场景**：  
并发插入操作最容易发生死锁（多个线程均持有某插入位置的间隙锁时，线程执行插入操作的插入意向锁全部会被阻塞，并陷入死锁）。（主要因为间隙锁之间共享）  
新增订单时做幂等性校验，通过当前读确定订单不存在。  
**死锁的必要条件**：  
（1）互斥；  
（2）占有且等待；  
（3）不可强占用；  
（4）循环等待。  
**MySQL解决死锁问题方案**：通过打破循环等待条件解除死锁：  
（1）设置事务等待锁的超时时间；  
（2）开启主动死锁检测。  
**更好的方案是从业务的角度避免死锁问题出现**。（例：对订单做幂等性校验，业务层面确保无重复订单，数据库设置order_id为唯一索引。缺点：插入已存在订单时抛出异常）  
避免同一个事务里出现对相同位置的更新/当前读和插入。（个人观点）
# MySQL分布式
