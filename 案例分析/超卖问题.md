**超卖问题**：并发环境下，大量下单请求同时发给服务，导致售出商品数量超过商品库存的问题。
>Tips：面试官考察超卖问题，实际上是一个综合考察，涵盖了MySQL原理&并发解决方案&实践+业务场景并发解决方案+Redis应用场景分析&实践。  

>Tips：此外，超卖问题，通常是秒杀系统常见的问题。在解决超卖问题的基础上，还可以思考下如何解决：库存卖空后，大量下单请求导致服务器压力过大问题。  

**超卖问题如何产生？**  
>Tips：实际上超卖问题并不容易发生，只有对**数据库可重复读&锁机制不了解**且使用了**持久层框架提供的数据库接口**的情况下才会比较常见。  

超卖问题只会在业务代码中进行数据库的非原子操作时才会发生。步骤如下：  
（1）使用快照读获取数据；  
（2）在业务层计算更新值并更新。
>Tips：因为是快照读，所以其获取数据的时刻，其他事务仍可以修改被读取的数据行，而且其获取的数据也可能不是最新版本，二者都可能造成并发安全问题。  

**超卖问题必须要引入外部机制解决么？**  
答案是否定的，实际上通过MySQL的锁机制就可以很好地解决超卖问题。  
悲观锁方案：当前读的语句（包括当前读&删改）不会导致超卖问题，因为当前读会锁行。 
```SQL
update good_table set store=store-1  
where id=xxxx and store >= 1;
```
>Tips：避免使用 **store - 1 >= 0** 的条件，该条件会导致索引失效，造成性能问题。正确的条件应该如上。  

>Tips：看到了乐观锁方案（感觉版本号方案很拉胯啊...），要求改为读已提交隔离级别（这就很抽象了），有的叙述里甚至没提这一点，快照读的乐观锁方案版本号如果是可重复读级别下获取的可信么？  

**那么超卖问题就变为了**：是否存在比悲观锁方案性能更好的超卖问题解决方案？
答案是肯定的，这里提出一个方案。  
使用Redis做库存预扣逻辑，并且可以实现库存个位数级别的锁粒度。（上文语句为行锁，会阻止其他并发用户下单）  
>Tips：库存个位数级别的锁粒度：举例说明，剩余10个库存，此时下1单，即锁住第10个库存，但是其他下单用户可以对第9，8，7单下单。
