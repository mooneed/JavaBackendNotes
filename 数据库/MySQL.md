# 概述
**强调**，对于任何一个开发人员来说应该熟练掌握MySQL原理。  
**MySQL网课**：MySQL45讲-丁奇（**`MySQL核心参考资料`**）（学习曲线较平缓，知识点之间分离度较低，有深度）  
**MySQL博客**：
[小林coding]()（学习曲线平缓，快速入门）
[MySQL江湖路|专栏目录](https://blog.csdn.net/qq_39390545/article/details/107786761)（可参考，对MySQL45讲有一定补充）  
**数据库作用**：数据库用于存储和读取数据，对于业务端来说是一种共享资源。  
数据库理论的各种架构设计主要为了保证数据库系统的高性能，数据一致性，高可用性。  
下述架构设计中，√代表其主要目的，×代表对其他核心目的造成了负面影响。  
| 架构设计名称 | 高性能 | 一致性 | 高可用性 | 备注 |
| :-------------: | :-: | :---: | :--: | :------------: |
|     索引    |   √   |        |         |      |
| 数据库缓存  |  √  |   ×   |      |   MySQL有自己的缓存机制（分为写入缓存和查询缓存）  |
| 分库分表    |  √  |       |      |                |
| 读写分离    |  √  |       |      |                |
| 引入外部中间件 |  √  |   ×   |      |    ES，远程缓存等    |
| 事务        |     |   √   |      |                |
| 锁        |  ×  |   √   |      |                |
| MVCC（undolog实现） |  √  |   √   |      |                |
| 主备       |     |   ×   |   √  |  主备延迟越短，可用性越高  |
| redolog\&binlog |  √  |   √   |   √  | （1）WAL技术减轻写盘压力；（2）保证MySQL崩溃/主机宕机的数据一致性；（3）binlog是分布式数据系统架构的同步核心（分布式是高可用的核心）|

**数据库的主要指标**：每秒事务数TPS，每秒查询数QPS。  
# 事务
事务的特性AICD  
并发问题  
事务的隔离级别  
隔离级别的实现  
MVCC  
>Tips：MVCC是乐观锁思想的一种实现，并不等同于乐观锁。MVCC基于乐观锁的思想认为在一个事务访问某数据时，别的事务不会/很少删改该数据。在这种情况下，就可以用很少的代价暂时存储该数据的历史版本链（undolog实现）。对于访问该数据的事务，在其整个事务生命周期内，其他事务的删改是不可见的。  

隔离级别的选择（数据一致性要求高选择可重复读，要求不高选择读已提交，什么场景数据一致性要求不高？）  
在可重复读隔离级别下，很大程度上避免了幻读问题。（未完全解决）  
MVCC解决快照读幻读问题。  
LBCC解决当前读幻读问题。  
**未被解决的幻读场景**：对于事务A的快照读不可见的数据，在当前读时是可见的。  
# MySQL日志
**MySQL日志包括**：  
（1）**三大日志**：二进制日志binlog（默认关闭），redolog，undolog；（具体参见下文）  
（2）其他日志：错误日志errorlog，慢查询日志slowlog，一般查询日志generallog（建议关闭，且默认关闭）；  
（3）MySQL 8新增日志：中继日志relaylog（负责从服务器暂存主服务器binlog的中间文件），数据定义语句日志。  
本章节主要介绍三大日志。
## binlog
binlog全称binary log（二进制日志）。  
>Tips：为什么叫二进制日志？因为其以二进制的形式存储在文件中（区别于文本文件），具有以下优点：  
（1）高性能：可以直接被数据库引擎读取和写入，无需文本解析；  
（2）安全性：可以使用更复杂的算法实现数据压缩/加密。
### 作用
（1）逻辑备份，用于**备份恢复**；  
（2）数据系统高性能&高可用方案的同步核心（用于对Redis、ES等**从数据库**的同步，同理于备份恢复）。  
>Tips：备份恢复：即业务出于数据恢复考虑，定期进行数据全量备份，全量备份副本+binlog可以恢复到任何一个时间节点。业务根据数据恢复的需求决定数据全量备份的频率，平衡全量备份的资源消耗&备份恢复时执行过多SQL语句的资源消耗的容忍程度（两难抉择）。  
（1）与崩溃恢复的区别：redolog实现的崩溃恢复，仅应用于服务崩溃/硬件宕机后的数据恢复；  
（2）与回滚的区别：undolog实现的数据回滚，其能够恢复数据的时间范围太小。  
redolog和undolog都会较快地被垃圾回收。  

### 写入机制
>Tips：binlog也利用了缓存技术，并通过sync_binlog参数控制缓存使用策略，平衡性能&丢失数据风险的容忍程度。  

**写入机制流程**：（以事务为写入的逻辑单位，会在**事务提交后再写入binlog**）  
（1）事务执行过程中，先把日志写入binlog cache中；  
（2）事务提交时，把binlog cache通过write写入binlog文件中（指写入文件系统的page cache，并未持久化到磁盘，速度较快）；  
（3）将page cache中的数据，通过fsync操作写入磁盘（占用磁盘IOPS每秒读写次数）。  
**binlog cache**：MySQL为**每个线程**分配一个binlog cache内存，通过**binlog_cache_size参数**控制单个线程binlog cache的内存大小（binlog cache满后写入数据则暂存到磁盘）。   
>Tips：为什么线程独有？

**sync_binlog参数**：控制write和fsync的时机。  
（1）0：只write不fsync；  
（2）1：每次提交事务都fsync；  
（3）N：每次提交都write累计N次事务后才fsync。  
在IO瓶颈的场景里，会将sync_binlog设置成较大的值提升性能，考虑到丢失日志量的可控性，一般不设置为0，通常设置为100-1000（主机宕机会丢失N个事务的binlog）。  
### 数据格式
**statement格式**：直接记录SQL语句。  
![statement格式](https://github.com/mooneed/ImageBed/assets/37293242/c4be64fd-af8f-4e24-a6df-57bf0e5237f2)
**row格式**：记录SQL语句对应的event（table_id，row_id等）。（**`主流`**）   
如下述Table_map事件（说明要操作的表）和Delete_rows事件（定义删除操作）。  
![row格式](https://github.com/mooneed/ImageBed/assets/37293242/fcc5486b-1972-4555-9019-72fbe2b16235) 
>Tips：由于row格式直接记录对应行号的增删改，因此不会在同步过程中出现主备数据不一致问题。  

**mixed格式**：上述两种格式混合使用，利用了各自的优点。（statement格式占空间少，row格式强数据一致性）
>Tips：目前越来越多的场景要求使用row格式，如：
（1）大量并发插入操作（Auto-INC的轻量级锁使用statement格式存在主备数据不一致）；  
（2）。  
此外，固态硬盘和万兆光纤使得row格式的磁盘IO和网络IO都在可接受范围内。  
### 相关参数汇总
**log_bin**：表示binlog是否开启（默认关闭）。  
>开启方式：在my.cnf主配置文件中，找到[mysqld]模块，添加log-bin=/var/lib/mysql/mysql-bin  

```SQL
// 查看binlog是否开启
show variables like '%log_bin%';
```
**max_binlog_size**：单个二进制日志文件的最大容量（默认1G）。  
**binlog_cache_size**：每个事务持有的binlog缓存最大容量（默认32k）。  
>Tips：大事务会超过该容量，需开启binlog临时文件参数，影响性能。  
**binlog_format**：binlog数据格式（默认row，5.7实测）。  
**sync_binlog**：控制凑满多少次事务的binlog缓存写入一次磁盘。  

## redolog
redolog的提出实际上是解决由于引入数据库写入缓存而导致的数据一致性问题。（简述就是增删改操作优先写入缓存，并在MySQL服务器不忙的时候再批量持久化的一种削峰策略。但是该策略的部分数据会存储在内存中，如果没有来得及持久化时，出现**服务崩溃/硬件宕机**，则会导致丢失数据）详见[MySQL45讲第2节（无链接）]()。  
>Tips：redolog实际上是应用一种叫做WAL的技术，来提高MySQL的写入性能（即上文简述的削峰策略）。WAL的目的是减少高峰时期磁盘写，虽然引入的redolog本身也需要进行磁盘写，但redolog的磁盘写比数据的磁盘写性能高，主要原因：  
（1）日志磁盘写为顺序写，速度快于数据的磁盘随机写。  
（2）组提交机制（见下文）可以大幅降低磁盘的IOPS消耗。
### 作用
（1）物理日志（记录数据页上的操作），用于**崩溃恢复**（解决上文所述的数据不一致问题）；  
（2）WAL技术：磁盘写压力削峰。  
### 写入机制
**写入机制流程**：（以事务为写入的逻辑单位）  
**innodb_flush_log_at_trx_commit参数**：  
（1）0：每次提交事务redolog存在redolog buffer中；  
（2）1：每次提交事务redolog持久化到磁盘（prepare状态即持久化，commit状态只需write到page cache）；  
（3）2：每次提交事务redolog写入page cache。（0如果MySQL异常重启丢日志，2如果主机宕机丢数据，相对风险较小）。  
**三种未提交事务但redolog写盘的场景**：
（1）定时写盘：InnoDB有一个后台线程，每隔1秒，将redolog buffer中的日志调用write写入page cache，然后调用fsync持久化到磁盘。（未提交事务的redolog在redolog buffer中也会被持久化）  
（2）redolog buffer占用空间过半：后台线程会主动写盘（仅write到page cache）。  
（3）并行事务提交：innodb_flush_log_at_trx_commit为1时，提交事务时将redolog buffer全部持久化到磁盘（包括未提交的事务）。  
**MySQL双1配置**：（双1配置是默认配置）即innodb_flush_log_at_trx_commit和sync_binlog均为设置1。
**非双1配置适用场景**：（通常为redolog配置为2，binlog配置为1000）  
（1）业务高峰期；  
（2）备库延迟，让备库尽快与主库同步时；  
（3）用备库恢复主库时；  
（4）批量导入数据时。  
**MySQL的TPS性能**：日志写入的磁盘操作引入了组提交group commit机制提升TPS性能。  
**组提交group commit机制**：（利用并发事务的多次磁盘写合并为1次磁盘写提升TPS性能）日志逻辑序列号LSN单调递增。当多个并发事务同时处在持久化过程时，写盘时的最小LSN携带最大的LSN的值，一次性持久化所有LSN小于等于该值的数据。不太了解实现。  
组提交的组员越多，节约磁盘IOPS效果越好，但只对并发事务有效。  
因为组提交机制的存在，fsync调用的越晚性能越好（因为组员多）。因此binlog和redolog都是write和fsync分开调用的。  
通常redolog的fsync速度较快，因此binlog的write和fsync的时间间隔较短，组提交的效果通常不如redolog。可以使用参数提升binlog组提交效果：（两个参数是或关系）  
**binlog_group_commit_sync_delay参数**：延迟多少ms后调用fsync（设为0时，下述count参数无效）。  
**binlog_group_commit_sync_no_delay_count参数**：累计多少事务后fsync。  
## undolog
undolog由InnoDB提供支持，最初的目的是对事务的原子性提供支持（即执行失败的事务通过undolog回滚到该事务没有执行的状态），后续又支持了MVCC快照读。  
### 作用
（1）回滚执行失败的事务（保证事务的原子性）；  
（2）实现MVCC快照读（undolog+隐式字段）。  （快照读见MVCC小节）
### 写入机制
### 数据格式
## 三大日志写入流程

# 性能优化
学习**性能优化**一节的顺序通常应该放置在索引和锁后。但是由于高性能是MySQL设计和使用的核心目标之一，且性能优化是对索引的利用，以及对锁引发的性能问题的规避。因此，先学习性能优化能够更好地理解索引的原理以及锁的缺点。（**`对于本节出现的索引和锁的相关概念可以略读后两节`**）
## 慢查询优化
## 并发锁问题
锁导致的各种性能问题。
### 安全更新
更新或删除语句为当前读，如果没有使用索引的话，会导致整个表被锁住，造成业务停滞（阻塞增删改操作）。  
**解决方案**：设置参数sql_safe_updates为1。  
>update语句必须满足如下条件之一才能执行成功：  
（1）使用where，且条件中必须有索引列；  
（2）使用limit；  
（3）同时使用where和limit，条件中可以没有索引列。  
delete语句必须满足以下条件能执行成功：  
（1）同时使用where和limit，条件中可以没有索引列。  
Tips：如果优化器最终选择扫描全表，请手动force index([index_name])。  
### 避免死锁
（1）尽量减少事务持有锁的个数（拆分事务）；  
（2）DML与增删改查分离，避免增删改查持有锁的时间过长；  
（3）等。  
>此外优化SQL，合理增加索引，减少SQL执行时间，也可以减少锁的持有时间，避免死锁问题。  

# 索引

# 锁
锁，**以烧水为例**：有3壶水需要烧开，但是只有一个烧水壶，在烧水壶烧水的时候，必定有一壶水占用了烧水壶，不允许另外2壶水使用。该过程中的**水占用烧水壶并阻止其他水使用烧水壶即为锁**。此时烧水壶是**共享资源**，3壶水各是1位**竞争者**。  
在MySQL中，竞争者为不同的线程/事务，共享资源为数据库中的数据，线程/事务占用数据时对数据加锁。  
**锁的作用**：处理并发环境下的数据一致性问题。  
**锁引入的问题**：降低性能。  
**锁的性能问题的解决方案**：降低锁的粒度，采用乐观锁，避免死锁，等。  
**MySQL锁包括**：  
（1）全局锁；  
（2）表级锁：表锁，元数据锁，意向锁（InnoDB支持），AUTO-INC锁（InnoDB支持）；  
（3）行级锁（InnoDB支持）：记录锁，间隙锁，临键锁，插入意向锁。   
## 全局锁
顾名思义，对整个数据库加锁。实际上全局锁可以解决所有并发问题，但是性能过差所以被淘汰，仅剩下文所述的应用场景。  
**全局锁的作用**：使整个数据库处于只读状态：阻塞数据的增删改操作，阻塞表结构的更改操作。  
**全局锁的加/解锁语句**：  
```SQL
// 加锁
flush tables with read lock
// 解锁
unlock tables
```  
**全局锁的适用场景**：全库逻辑备份。  
**全局锁的缺点**：造成业务停滞（不能增删改数据）。  
**全局锁的上位替代**：MVCC实现的可重复读隔离级别（InnoDB支持）。对快照读的数据进行全库逻辑备份可以确保数据一致性（缺点：需要一个长事务执行全库逻辑备份）。  
## 表级锁
**表级锁的加锁对象**：表。
### 表锁
顾名思义，表锁就是对整张表加锁。表锁可以解决所有的并发问题，但是碍于性能原因，所以一方面拆分出了其他表级锁（意向锁除外），在解决更具体并发问题的同时提升性能，另一方面InnoDB提供了行级锁代替表锁处理行级的并发问题。  
**表锁的作用**：行锁出现前，处理并发数据不一致问题的主要锁。  
**表锁的加/解锁语句**：
```SQL
// 表级锁粒度的共享锁（读锁）
lock tables t_student read;
// 表级锁粒度的独占锁（写锁）
lock tables t_student write;
// 释放当前会话所有表锁
unlock tables
```
**表锁的缺点**：粒度大，影响并发性能。  
**表锁的适用场景**：（待研习，读者请跳过或自行学习）  
（1）事务更新大部分时；  
（2）事务涉及多个表，容易引起死锁，造成事务回滚。  

### 元数据锁MDL
**元数据锁的作用**：对表执行CRUD操作时，防止其他事务对表结构进行更改。  
**元数据锁的加/解锁**：MDL锁由MySQL隐式自动加/解锁。对表执行CRUD操作时加**MDL读锁**，对表结构执行更改操作时加**MDL写锁**，事务提交后自动**释放**。  
**元数据锁的缺点**：MDL写锁阻塞orMDL写锁加锁，都会导致MDL读锁全部阻塞。（前者因为在MDL锁阻塞队列中MDL写锁的优先级高于MDL读锁，后者因为事务提交后MDL写锁才会被释放）（例：长事务导致阻塞MDL写锁or长事务中使用MDL写锁）  
### 意向锁
**意向锁的作用**：加独占表锁时，快速判断表中是否有行锁（如果没有意向锁的话，加独占表锁时需要逐行检查是否有行锁）。（**`意向锁仅和表锁冲突`** 从其作用也很容易看出）  
>Tips：表锁与行锁也满足读读共享，读写/写写互斥。

**意向锁的加/解锁语句**：（加/解锁记录锁时自动加/解锁）  
```SQL
// 先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;
// 先在表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
// 事务提交后自动释放
```
### AUTO-INC锁
**AUTO-INC锁的作用**：保证自增主键（声明AUTO_INCREMENT的主键字段）的自动连续递增（自动：插入数据时无需指定主键值）。  
**AUTO-INC锁的加/解锁**：对主键自增的表执行插入操作时，自动加锁；插入操作执行完成后，自动释放（而非事务提交后释放）。  
**AUTO-INC锁的缺点**：表级锁，在大量插入时影响插入性能。  
**AUTO-INC锁的改进**：InnoDB支持通过变量innodb_autoinc_lock_mode设置自增锁模式，0为AUTO-INC锁，2为轻量级锁（申请自增主键后立即释放，无需等待语句执行）。
>Tips：轻量级锁搭配binlog的statement格式时，会导致主从复制数据不一致问题（解决方案为使用row格式binlog）。多种场景下statement格式均易导致主从复制数据不一致问题，详见上文**MySQL日志**一节。  
## 行级锁
>行级锁由InnoDB引擎提供支持。  

**行级锁的加锁对象**：记录行对应的索引。  
**行级锁的加锁**会根据语句的扫描方式不同，而有不同的加锁方案：  
（1）主键索引扫描；  
（2）二级索引扫描；  
（3）全表扫描。  
>Tips：对于执行全表扫描的语句，会对每一条记录的索引加临键锁，相当于锁定整个表（必须避免）。  

InnoDB默认优先加**临键锁**，非可重复读隔离级别加记录锁（因为间隙锁/临键锁仅存在于可重复读隔离级别）；部分可重复读隔离级别的场景下，临键锁退化为间隙锁/记录锁。**间隙锁/临键锁为了解决可重复读隔离级别的幻读问题**。  
本笔记主要介绍各行级锁的作用以及用法（略读时，可以简单的理解为InnoDB可重复读隔离级别全部使用临键锁，其他级别使用记录锁）。具体加锁分析，详见[小林coding图解MySQL](https://www.xiaolincoding.com/mysql/lock/how_to_lock.html)。
>Tips：在大多数生产环境中，表都是使用单调递增主键（如自增主键，UUID，雪花ID等），在插入操作时都是尾插，因此对间隙锁、临键锁、插入意向锁的使用频率较小。（个人观点，未验证）  

**行级锁的加/解锁语句**：（记录锁，间隙锁，临键锁共用语句）  
（1）当前读（会对记录加锁。普通的select语句为快照读，不会对记录加锁）  
```SQL
// 加共享锁
select ... lock in share mode;
// 加独占锁
select ... for update;
// 事务提交后自动释放
```
（2）增删改操作（也为当前读）：执行增删改语句时自动加锁，事务提交后自动释放。  
>Tips：在读提交和可重复读隔离级别下，由于MVCC机制的存在，快照读并不会被独占锁阻塞。  

### 记录锁
记录锁会锁定一条记录，实际上是**锁定记录对应的索引**，如果是二级索引扫描方式则锁定记录对应的二级索引和主键索引。  
**记录锁的作用**：处理并发数据不一致问题的主要锁。  
**记录锁的加/解锁**：非可重复读隔离级别下的默认行级锁；在可重复读隔离级别的部分场景下，临键锁降级为记录锁。  
### 间隙锁
间隙锁会锁定一个范围，阻塞在该范围内的插入操作。  
**间隙锁的作用**：解决可重复读隔离级别下的幻读问题（仅存在于可重复读隔离级别）。（**`间隙锁之间共享`**，因为间隙锁的目的是防止插入幻影记录，幻读问题详见**事务**一节）  
**间隙锁的加/解锁**：在可重复读隔离级别的部分场景下，临键锁降级为间隙锁。

### 临键锁
临键锁是行锁+间隙锁的组合。既锁定一个范围，又锁定记录本身。  
间隙锁为前开后开，临键锁为前开后闭。（需配图）  
**临键锁的作用**：同时起到记录锁和间隙锁的作用。  
**临键锁的加/解锁**：可重复读隔离级别下的默认行级锁。  
>Tips：在使用记录锁/间隙锁就能避免幻读问题的场景下，临键锁就会退化为记录锁/间隙锁。  

>Tips：禁用间隙锁时，临键锁也会被禁用。  
### 插入意向锁
**插入意向锁的作用**：插入前判断插入位置是否存在间隙锁，有则阻塞插入操作（相当于插入操作的锁，删改查有对应的行级锁，而增没有）。（**`插入意向锁之间共享`** ）  
**插入意向锁的加/解锁**：执行插入操作前，自动加锁；。  
## 死锁问题
死锁问题建议精读小林coding的死锁章节的案例分析[1](https://www.xiaolincoding.com/mysql/lock/deadlock.html)，[2](https://www.xiaolincoding.com/mysql/lock/show_lock.html#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C)。  
**死锁容易发生的场景**：  
并发插入操作最容易发生死锁（多个线程均持有某插入位置的间隙锁时，线程执行插入操作的插入意向锁全部会被阻塞，并陷入死锁）。（主要因为间隙锁之间共享）  
新增订单时做幂等性校验，通过当前读确定订单不存在。  
**死锁的必要条件**：  
（1）互斥；  
（2）占有且等待；  
（3）不可强占用；  
（4）循环等待。  
**MySQL解决死锁问题方案**：通过打破循环等待条件解除死锁：  
（1）设置事务等待锁的超时时间；  
（2）开启主动死锁检测。  
**更好的方案是从业务的角度避免死锁问题出现**。（例：对订单做幂等性校验，业务层面确保无重复订单，数据库设置order_id为唯一索引。缺点：插入已存在订单时抛出异常）  
避免同一个事务里出现对相同位置的更新/当前读和插入。（个人观点）
# MySQL分布式
通常主从延迟在200ms左右。  
# 相关复合问题汇总
## 长事务的缺点
（1）更容易导致锁冲突&死锁（部分锁在事务提交时才会释放，导致锁持有时间变长）；  
（2）导致binlog cache溢出，影响性能；  
（3）导致主备延迟时间长（事务提交才会写入binlog，长事务意味着在备库的执行时间长，因而导致延迟时间长）；  
（4）。  
## 数据不一致的场景
